#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Copyright 2013, 2014, 2016, 2017 Guenter Bartsch
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#
# Voice Activity Detection (VAD) daemon
#
# listens on pulseaudio connected audio input for voice activity
# once detected, publishes recorded audio frames via MQTT
#

import traceback
import json
import logging
import datetime

import paho.mqtt.client as mqtt

from time                  import time
from nltools               import misc
from nltools.pulserecorder import PulseRecorder
from nltools.vad           import VAD, BUFFER_DURATION
from optparse              import OptionParser


PROC_TITLE            = 'mqtt_vad'
TOPIC_CONFIG          = 'ai/config'
TOPIC_INPUT_AUDIO     = 'ai/input/audio'
TOPIC_BOOT            = 'hal/boot'
RETRY_DELAY           = 3

SAMPLE_RATE           = 16000
FRAMES_PER_BUFFER     = SAMPLE_RATE * BUFFER_DURATION / 1000

DEFAULTS = {
            'broker_host'   : 'localhost',
            'broker_port'   : '1883',
            'broker_user'   : '',
            'broker_pw'     : '',
            'source'        : 'CM108',
            'volume'        : 150,
            'aggressiveness': 2,
           }

vad_enabled = True

#
# MQTT
#

def on_connect(client, userdata, flag, rc):
    if rc==0:
        logging.info("connected OK Returned code=%s" % repr(rc))
        client.subscribe(TOPIC_CONFIG)
    else:
        logging.error("Bad connection Returned code=%s" % repr(rc))

msg_cnt = 0

def on_message(client, userdata, message):

    global msg_cnt, vad_enabled

    # logging.debug( "message received %s" % str(message.payload.decode("utf-8")))a
    msg_cnt += 1
    logging.debug( "message received #%06d" % msg_cnt)
    logging.debug( "message topic=%s" % message.topic)
    logging.debug( "message qos=%s" % message.qos)
    logging.debug( "message retain flag=%s" % message.retain)

    try:

        if message.topic == TOPIC_CONFIG:

            logging.debug("ai/input/listen: '%s'" % message.payload)

            vad_enabled = json.loads(message.payload)['listen']

    except:
        logging.error('EXCEPTION CAUGHT %s' % traceback.format_exc())


#
# init
#

misc.init_app(PROC_TITLE)

#
# load config, set up global variables
#

config = misc.load_config('.halrc', defaults = DEFAULTS)

broker_host    = config.get   ("mqtt", "broker_host")
broker_port    = config.getint("mqtt", "broker_port")
broker_user    = config.get   ("mqtt", "broker_user")
broker_pw      = config.get   ("mqtt", "broker_pw")

loc            = config.get   ("vad",  "loc")
source         = config.get   ("vad",  "source")
volume         = config.getint("vad",  "volume")
aggressiveness = config.getint("vad",  "aggressiveness")

#
# cmdline, logging
#

parser = OptionParser("usage: %prog [options]")

parser.add_option ("-v", "--verbose", action="store_true", dest="verbose",
                   help="verbose output")

parser.add_option ("-H", "--host", dest="host", type = "string", default=broker_host,
                   help="broker host, default: %s" % broker_host)

parser.add_option ("-p", "--port", dest="port", type = "int", default=broker_port,
                   help="broker port, default: %d" % broker_port)

(options, args) = parser.parse_args()

if options.verbose:
    logging.basicConfig(level=logging.DEBUG)
else:
    logging.basicConfig(level=logging.INFO)


logging.info ('HAL 9000 VAD application started. Audio source: %s' % source)

#
# pulseaudio recorder
#

rec = PulseRecorder (source, SAMPLE_RATE, volume)

logging.debug ('PulseRecorder initialized.')

#
# mqtt connect
#

logging.debug ('connecting to MQTT broker %s:%d ...' % (broker_host, broker_port))

client = mqtt.Client()
client.username_pw_set(broker_user, broker_pw)
client.on_message=on_message
client.on_connect=on_connect

connected = False
while not connected:
    try:

        client.connect(broker_host, port=broker_port, keepalive=10)

        connected = True

    except:
        logging.error('connection to %s:%d failed. retry in %d seconds...' % (broker_host, broker_port, RETRY_DELAY))
        time.sleep(RETRY_DELAY)

logging.debug ('connecting to MQTT broker %s:%d ... connected.' % (broker_host, broker_port))

client.loop_start()

#
# VAD
#

vad = VAD(aggressiveness=aggressiveness, sample_rate=SAMPLE_RATE)

#
# main
#

client.publish(TOPIC_BOOT, 'vad')
rec.start_recording(FRAMES_PER_BUFFER)

while True:

    logging.debug ("recording...")

    samples = rec.get_samples()

    # logging.debug("%d samples, %5.2f s" % (len(samples), float(len(samples)) / float(SAMPLE_RATE)))

    if not vad_enabled:
        continue

    audio, finalize = vad.process_audio(samples)

    if not audio:
        continue

    logging.debug ('sending audio len=%d finalize=%s audio=%s' % (len(audio), repr(finalize), audio[0].__class__))

    data = {'final': finalize, 'ts': datetime.datetime.now().isoformat(), 'pcm': audio, 'loc': loc}
    client.publish(TOPIC_INPUT_AUDIO, json.dumps(data))

